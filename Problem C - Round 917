#include <bits/stdc++.h>
using namespace std;

#define sr srand(time(0));
#define ra(l, h) (rand() % ((h)-(l)+1) + (l))
#define sync { ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); }
#define ll long long int
#define vi vector<int>
#define fn(n) for(int i = 0; i < n; i++)
#define fr(i, a, b) for(int i = a; i <= b; i++)
#define rfr(i, a, b) for(int i = a; i >= b; i--)
#define pb push_back
#define all(a) a.begin(), a.end()
#define tt int test; cin >> test; while(test--)
#define ff first
#define ss second
#define en cout<< "\n"
#define cy cout << "YES" << endl
#define cn cout << "NO" << endl



unordered_map<int, int> um;

int sameIndex(vi &a, int n){
    int sameI=0;
    fn(n){
        if(a[i]==i+1) sameI++;
    }
    return sameI;
}

int countInMap(vi &a, int n, int x){
    fn(n){
        int di = i+1 - a[i];
        um[di]++;
    }
    if (um.find(x) == um.end()) {
        um[x] = 0;
    } 
    return um[x];

}


int main() {
    sync
    tt {
        int n, k, d;
        cin >> n >> k >> d;
        
        vi a(n);
        fn(n) cin>>a[i];
        
        vi v(k);
        fn(k) cin>>v[i];
        
        
        /*
        1 2 3   1 3 2 3 
        
        */
        
        
        
        int score = 0;
        int nextSame = 0;
        fn(d){
            int sameIndexVal = sameIndex(a, n);
            if(i+1 < k) nextSame = countInMap(a, v[i+1], 1);
            
            // fn(n) cout<<a[i]<<" ";
            // en;
            // for(auto v: um) cout<<v.ff<<" "<<v.ss<<endl;
            // en;
            // cout<<"sameIndex: "<<sameIndexVal<<endl;
            // cout<<"nextSame: "<<nextSame<<endl;
            if(sameIndexVal < nextSame && i+1<k){
                if(i<d-1) score += nextSame;
                fn(v[i+1]) a[i]++;
                i++;
            } else {
                score += sameIndexVal;
                fn(n) a[i] = 0;
            }

            um.clear();
        }
        

        cout << score << endl;
        
        
    }
    return 0;
}



/*

    // d = 4 
    // 1 2 3 
    // 1 3 2 3 
    // 1 2 3 = 0 0 0    1   3
    // 0 0 0 = 1 1 1    3
    // 1 1 1 = 2 2 1    2
    // 2 2 1 = 0 0 0    4   3+1
    
    6 2 3
    6 1 2 4 1 5
    6 6
    
    6 1 2 4 1 5
    
    
    
    

*/
